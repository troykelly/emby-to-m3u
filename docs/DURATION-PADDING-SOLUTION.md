# Duration Padding Solution - Filling Playlist Time Slots

## Problem

Playlists generated by the LLM often contain too few tracks to fill their allocated daypart time slots. This results in short playlists that don't cover the full broadcast period.

### Example Issue

**After Hours** playlist (19:00-00:00, 5 hours):
- **Target**: 60-75 tracks, 300 minutes (18,000 seconds)
- **Actual**: 55 tracks, 190 minutes (11,395 seconds)
- **Gap**: 110 minutes (63.3% fill rate)

This means the playlist stops playing almost 2 hours before the daypart ends!

## Root Cause

The LLM track selection returns fewer tracks than needed to fill the daypart duration. Possible reasons:
1. Library size constraints (limited matching tracks)
2. Strict constraint satisfaction prioritized over quantity
3. LLM stopping early when it feels it has "enough" tracks
4. No explicit duration requirement in the prompt (only track count)

## Solution: Duration Padding with Progressive Constraint Relaxation

Add a post-LLM step that:
1. **Validates minimum duration** (at least 90% of daypart duration)
2. **Adds padding tracks** if duration is insufficient
3. **Uses progressive constraint relaxation** to find additional tracks
4. **Prevents duplicates** by tracking already-used track IDs
5. **Maintains playlist quality** by relaxing constraints gradually

### High-Level Algorithm

```python
def pad_playlist_to_duration(
    playlist: Playlist,
    target_duration_minutes: int,
    subsonic_client: SubsonicClient,
    spec: PlaylistSpecification,
    used_track_ids: set
) -> Playlist:
    """
    Pad playlist with additional tracks to meet minimum duration requirement.

    Args:
        playlist: Initial playlist from LLM
        target_duration_minutes: Target daypart duration
        subsonic_client: Subsonic client for querying additional tracks
        spec: Original playlist specification
        used_track_ids: Set of track IDs already used (for deduplication)

    Returns:
        Padded playlist meeting minimum duration (90% of target)
    """
    MIN_FILL_PERCENTAGE = 0.90  # Require 90% of target duration

    # 1. Calculate current duration
    current_duration = sum(track.duration_seconds for track in playlist.tracks)
    required_duration = target_duration_minutes * 60 * MIN_FILL_PERCENTAGE

    if current_duration >= required_duration:
        return playlist  # Already sufficient

    # 2. Calculate how many more tracks we need
    gap_seconds = required_duration - current_duration
    avg_track_duration = 210  # 3.5 minutes average
    tracks_needed = math.ceil(gap_seconds / avg_track_duration)

    logger.info(
        f"Playlist duration {current_duration/60:.1f}min is below target "
        f"{target_duration_minutes}min. Need {tracks_needed} more tracks."
    )

    # 3. Progressive constraint relaxation to find padding tracks
    padding_tracks = []
    relaxation_levels = [
        {"bpm_tolerance": 5, "genre_strict": True},   # Level 1: Slight BPM relaxation
        {"bpm_tolerance": 10, "genre_strict": True},  # Level 2: More BPM relaxation
        {"bpm_tolerance": 15, "genre_strict": False}, # Level 3: Genre mixing allowed
        {"bpm_tolerance": 20, "genre_strict": False}, # Level 4: Wider BPM range
        {"bpm_tolerance": None, "genre_strict": False}, # Level 5: Any BPM
    ]

    for level_idx, level in enumerate(relaxation_levels):
        if len(padding_tracks) >= tracks_needed:
            break

        logger.info(f"Trying constraint relaxation level {level_idx + 1}")

        # Query for additional tracks with relaxed constraints
        additional_tracks = query_padding_tracks(
            subsonic_client,
            spec,
            used_track_ids,
            tracks_needed - len(padding_tracks),
            level
        )

        padding_tracks.extend(additional_tracks)
        used_track_ids.update(t.track_id for t in additional_tracks)

    # 4. Add padding tracks to playlist
    playlist.tracks.extend(padding_tracks)

    # 5. Log padding operation
    new_duration = sum(track.duration_seconds for track in playlist.tracks)
    logger.info(
        f"Added {len(padding_tracks)} padding tracks. "
        f"Duration increased from {current_duration/60:.1f}min to {new_duration/60:.1f}min "
        f"({new_duration / (target_duration_minutes * 60) * 100:.1f}% fill)"
    )

    return playlist
```

## Implementation Steps

### 1. Add Duration Calculation to PlaylistSpecification

**File**: `src/ai_playlist/models/core.py`

Add `target_duration_minutes` field to `PlaylistSpecification`:

```python
@dataclass
class PlaylistSpecification:
    # ... existing fields ...
    target_duration_minutes: int  # NEW: Required daypart duration in minutes
```

### 2. Update Playlist Planner to Include Duration

**File**: `src/ai_playlist/playlist_planner.py`

Modify `create_playlist_spec()` to set `target_duration_minutes`:

```python
target_duration = _calculate_duration_minutes(daypart.time_range)

spec = PlaylistSpecification(
    # ... existing fields ...
    target_duration_minutes=target_duration,  # NEW
)
```

### 3. Create Duration Padding Module

**File**: `src/ai_playlist/duration_padding.py` (NEW)

Implement:
- `pad_playlist_to_duration()` - Main padding orchestrator
- `query_padding_tracks()` - Query Subsonic with relaxed constraints
- `calculate_padding_requirements()` - Determine how many tracks needed

### 4. Integrate into OpenAI Client

**File**: `src/ai_playlist/openai_client.py`

Add padding step in `generate_playlist()` after line 1284:

```python
# After: selected_tracks.append(core_track)
logger.info(f"Converted {len(selected_tracks)} LLM tracks to SelectedTrack objects")

# NEW: Check duration and pad if necessary
current_duration = sum(t.duration_seconds for t in selected_tracks)
target_duration_minutes = spec.target_duration_minutes
required_duration = target_duration_minutes * 60 * 0.90  # 90% minimum

if current_duration < required_duration:
    logger.warning(
        f"Playlist duration {current_duration/60:.1f}min is below minimum "
        f"{required_duration/60:.1f}min. Padding with additional tracks..."
    )

    # Import padding function
    from .duration_padding import pad_playlist_to_duration

    # Create temporary playlist for padding
    temp_playlist = CorePlaylist(
        id=spec.id,
        name=spec.name,
        specification_id=spec.id,
        tracks=selected_tracks,
        validation_result=None,  # Not validated yet
        created_at=datetime.now(),
        cost_actual=Decimal("0"),
        generation_time_seconds=0,
        constraint_relaxations=[]
    )

    # Pad playlist
    padded_playlist = await pad_playlist_to_duration(
        temp_playlist,
        target_duration_minutes,
        subsonic_client,
        spec,
        used_track_ids or set()
    )

    # Update selected_tracks with padded version
    selected_tracks = padded_playlist.tracks
    logger.info(f"Playlist padded to {len(selected_tracks)} tracks")

# Continue with validation (line 1287)
validation_result = validate_playlist(selected_tracks, spec.track_selection_criteria)
```

### 5. Update Prompts to Emphasize Duration

**File**: `src/ai_playlist/_prompt_builders.py`

Modify system prompt to emphasize duration requirements:

```python
## Duration Requirements

**CRITICAL**: The playlist MUST fill the complete {target_duration_minutes} minute time slot.

- Target duration: {target_duration_minutes} minutes
- Minimum acceptable: {target_duration_minutes * 0.90} minutes (90%)
- Average track length: 3.5 minutes
- **Estimated tracks needed**: {target_duration_minutes / 3.5} tracks

If you can only find {target_track_count_min} tracks meeting strict constraints,
that's acceptable - we'll add padding tracks afterward. However, try to get as
close to {target_track_count_max} tracks as possible.
```

## Benefits

1. **Guaranteed Coverage**: Every playlist fills at least 90% of its time slot
2. **Quality First**: LLM focuses on quality selections, padding handles quantity
3. **Progressive Relaxation**: Only relaxes constraints as much as needed
4. **No Duplicates**: Tracks already used are excluded from padding
5. **Efficient**: Only queries for padding when necessary

## Metrics to Track

- **Fill Percentage**: `(actual_duration / target_duration) * 100`
- **Padding Track Count**: Number of tracks added by padding
- **Relaxation Level Required**: How much constraint relaxation was needed
- **Average Track Duration**: For better padding estimation

## Testing

Create test cases for:
1. Playlist already meeting duration (no padding)
2. Playlist needing 10-20 tracks (moderate padding)
3. Playlist very short (aggressive padding)
4. Limited library (can't meet 90% even with full relaxation)

## Alternative Approaches Considered

### 1. Increase LLM Track Count Target
**Pros**: Simple, no code changes
**Cons**: Doesn't guarantee duration, wastes tokens on large counts

### 2. Add Duration to LLM Tool Schema
**Pros**: LLM aware of duration
**Cons**: LLM bad at math, unreliable, still needs fallback

### 3. Iterative LLM Calls
**Pros**: High quality throughout
**Cons**: Expensive ($$$), slow, complex state management

**CHOSEN**: Post-LLM padding with progressive relaxation
- Best balance of quality, cost, and reliability
- LLM focuses on best tracks, padding ensures quantity

## Expected Outcomes

### Before (Current State)
- After Hours: 55 tracks, 190 minutes (63% fill)
- The Session: 60 tracks, ~210 minutes (70% fill, 5-hour slot)
- Gaps of 60-110 minutes in playlists

### After (With Padding)
- After Hours: 75+ tracks, 270+ minutes (90%+ fill)
- The Session: 75+ tracks, 270+ minutes (90%+ fill)
- Maximum gap: 30 minutes (10% tolerance)

## Implementation Priority

**HIGH PRIORITY** - This directly impacts broadcast quality. Incomplete playlists cause:
- Dead air
- Repetition when playlist loops
- Poor listener experience

**Estimated Effort**: 4-6 hours
- Duration padding module: 2 hours
- Integration: 1 hour
- Testing: 1-2 hours
- Documentation: 1 hour
